<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Neon Dice</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #ui-overlay {
            position: absolute;
            top: 5%;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 2.5rem;
            text-transform: uppercase;
            letter-spacing: 5px;
            color: #ff3333;
            text-shadow: 0 0 15px #f00, 0 0 30px #f00;
            font-weight: 900;
        }

        p.instruction {
            font-size: 1.1rem;
            color: #ff8888;
            margin-top: 10px;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 5px #f00;
        }
    </style>
</head>
<body>

    <div id="ui-overlay">
        <h1>Neon Dice</h1>
        <p class="instruction">Klicka för att kasta</p>
    </div>

    <div id="canvas-container"></div>

    <!-- Importera Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Konfiguration ---
        const DICE_SIZE = 2;
        const FLOOR_Y = -2;
        const SHAKE_THRESHOLD = 15;

        // --- Variabler ---
        let scene, camera, renderer, diceMesh, diceGroup;
        let isRolling = false;
        
        // Skak-hantering
        let lastX, lastY, lastZ;
        let lastShakeTime = 0;

        // --- Initiering ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050000);
            scene.fog = new THREE.FogExp2(0x050000, 0.02);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 8, 11);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Ljus
            const ambientLight = new THREE.AmbientLight(0xffaaaa, 0.3);
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(0xffcccc, 1.2);
            spotLight.position.set(2, 15, 5);
            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 1024;
            spotLight.shadow.mapSize.height = 1024;
            scene.add(spotLight);

            const floorGlow = new THREE.PointLight(0xff0000, 2, 15);
            floorGlow.position.set(0, 0, 0);
            scene.add(floorGlow);

            // Golv
            const gridHelper = new THREE.GridHelper(50, 50, 0x550000, 0x220000);
            gridHelper.position.y = FLOOR_Y;
            scene.add(gridHelper);

            const planeGeometry = new THREE.PlaneGeometry(100, 100);
            const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.6 });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = FLOOR_Y;
            plane.receiveShadow = true;
            scene.add(plane);

            createDice();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousedown', attemptRoll);
            document.addEventListener('touchstart', (e) => {
                if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                    DeviceMotionEvent.requestPermission().then(response => {
                        if (response == 'granted') window.addEventListener('devicemotion', handleShake);
                    }).catch(console.error);
                }
                attemptRoll(e);
            }, { passive: false });

            if (window.DeviceMotionEvent) {
                window.addEventListener('devicemotion', handleShake);
            }

            animate();
        }

        // --- Texturer ---
        function createTexturedFace(number) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createRadialGradient(256, 256, 50, 256, 256, 300);
            gradient.addColorStop(0, '#400000');
            gradient.addColorStop(1, '#1a0000');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);

            const cornerRadius = 80;
            const padding = 20;
            
            ctx.strokeStyle = '#ff0033'; 
            ctx.lineWidth = 30;
            ctx.lineJoin = 'round';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 40;

            ctx.beginPath();
            if (ctx.roundRect) {
                ctx.roundRect(padding, padding, 512 - padding*2, 512 - padding*2, cornerRadius);
            } else {
                ctx.rect(padding, padding, 512 - padding*2, 512 - padding*2); // Fallback
            }
            ctx.stroke();

            ctx.strokeStyle = '#ff6666';
            ctx.lineWidth = 10;
            ctx.shadowBlur = 20;
            ctx.stroke();

            ctx.fillStyle = '#ffffcc';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 30;

            const radius = 45;
            const c = 256; 
            const o = 130;  

            const drawDot = (x, y) => {
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(x - 10, y - 10, radius/3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ffffcc';
            };

            if (number === 1) { drawDot(c, c); }
            else if (number === 2) { drawDot(c - o, c - o); drawDot(c + o, c + o); }
            else if (number === 3) { drawDot(c - o, c - o); drawDot(c, c); drawDot(c + o, c + o); }
            else if (number === 4) { drawDot(c - o, c - o); drawDot(c + o, c - o); drawDot(c - o, c + o); drawDot(c + o, c + o); }
            else if (number === 5) { drawDot(c - o, c - o); drawDot(c + o, c - o); drawDot(c, c); drawDot(c - o, c + o); drawDot(c + o, c + o); }
            else if (number === 6) { drawDot(c - o, c - o); drawDot(c + o, c - o); drawDot(c - o, c); drawDot(c + o, c); drawDot(c - o, c + o); drawDot(c + o, c + o); }

            return new THREE.CanvasTexture(canvas);
        }

        function createDice() {
            diceGroup = new THREE.Group();

            // Materialordning i BoxGeometry: Right, Left, Top, Bottom, Front, Back
            const materials = [
                new THREE.MeshStandardMaterial({ map: createTexturedFace(1) }), // Right
                new THREE.MeshStandardMaterial({ map: createTexturedFace(6) }), // Left
                new THREE.MeshStandardMaterial({ map: createTexturedFace(2) }), // Top
                new THREE.MeshStandardMaterial({ map: createTexturedFace(5) }), // Bottom
                new THREE.MeshStandardMaterial({ map: createTexturedFace(3) }), // Front
                new THREE.MeshStandardMaterial({ map: createTexturedFace(4) })  // Back
            ];

            const geometry = new THREE.BoxGeometry(DICE_SIZE, DICE_SIZE, DICE_SIZE);
            diceMesh = new THREE.Mesh(geometry, materials);
            diceMesh.castShadow = true;
            diceGroup.add(diceMesh);

            diceGroup.position.y = FLOOR_Y + DICE_SIZE/2;
            scene.add(diceGroup);
        }

        function attemptRoll(e) {
            if (isRolling) return;
            if (e && e.cancelable) e.preventDefault();
            rollDice();
        }

        function handleShake(event) {
            if (isRolling) return;
            const currentId = event.timeStamp;
            if (currentId - lastShakeTime < 1000) return;
            const acc = event.accelerationIncludingGravity;
            if (!acc) return;
            const delta = Math.abs(lastX - acc.x) + Math.abs(lastY - acc.y) + Math.abs(lastZ - acc.z);
            if (delta > SHAKE_THRESHOLD) {
                lastShakeTime = currentId;
                rollDice();
            }
            lastX = acc.x; lastY = acc.y; lastZ = acc.z;
        }

        // --- Korrigerad logik för målrotation (Quaternion) ---
        function getTargetQuaternion(result) {
            // Normalvektorer för BoxGeometrys sidor
            let normal;
            switch(result) {
                case 1: normal = new THREE.Vector3(1, 0, 0); break;  // Right
                case 6: normal = new THREE.Vector3(-1, 0, 0); break; // Left
                case 2: normal = new THREE.Vector3(0, 1, 0); break;  // Top
                case 5: normal = new THREE.Vector3(0, -1, 0); break; // Bottom
                case 3: normal = new THREE.Vector3(0, 0, 1); break;  // Front
                case 4: normal = new THREE.Vector3(0, 0, -1); break; // Back
            }

            // 1. Skapa en rotation som vider NORMALEN till att peka mot VÄRLDENS UPP (0, 1, 0)
            const qUp = new THREE.Quaternion().setFromUnitVectors(normal, new THREE.Vector3(0, 1, 0));

            // 2. Skapa en slumpmässig rotation runt VÄRLDENS Y-axel (0, 1, 0)
            // Detta gör att tärningen roterar "på golvet" utan att ändra vilken sida som är uppåt
            const randomAngle = Math.random() * Math.PI * 2;
            const qSpin = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), randomAngle);

            // 3. Kombinera rotationerna: Global Spin * Lokal Up-orientering
            const finalQ = new THREE.Quaternion().multiplyQuaternions(qSpin, qUp);
            
            return finalQ;
        }

        function rollDice() {
            isRolling = true;
            
            // Slumpa 1-6
            const result = Math.floor(Math.random() * 6) + 1;
            
            // Hämta korrekt målrotation som Quaternion
            const targetQ = getTargetQuaternion(result);

            const startTime = performance.now();
            const duration = 2000; 

            // Kaotisk spinn i luften (visuell effekt)
            const spinAxis = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
            const spinSpeed = 20 + Math.random() * 10;

            function animateStep(time) {
                const elapsed = time - startTime;
                let progress = elapsed / duration;

                if (progress < 1) {
                    let yPos = FLOOR_Y + DICE_SIZE/2;
                    
                    if (progress < 0.6) {
                        // Kast (Parabel)
                        const p = progress / 0.6; 
                        yPos += 8 * (p - Math.pow(p, 2)); 
                        
                        // Rotera i luften (bara visuell kaos)
                        diceGroup.rotateOnWorldAxis(spinAxis, spinSpeed * (1-p) * 0.15); 
                    } else {
                        // Landning & Studs
                        const p = (progress - 0.6) / 0.4;
                        
                        // Studsar
                        if (p < 0.4) {
                            const localP = p / 0.4;
                            yPos += 2.0 * Math.sin(localP * Math.PI);
                        } else if (p < 0.8) {
                            const localP = (p - 0.4) / 0.4;
                            yPos += 0.5 * Math.sin(localP * Math.PI);
                        }

                        // Magnetisk dragning mot rätt resultat
                        // Vi använder slerp för att mjukt tvinga rotationen mot targetQ
                        // Ju närmare slutet vi kommer, desto starkare blir dragningen
                        const magneticPull = (p * p) * 0.25; 
                        diceGroup.quaternion.slerp(targetQ, magneticPull);
                    }
                    
                    diceGroup.position.y = yPos;
                    requestAnimationFrame(animateStep);
                } else {
                    // SLUT: Tvinga exakt position och rotation
                    diceGroup.position.y = FLOOR_Y + DICE_SIZE/2;
                    diceGroup.quaternion.copy(targetQ); // Kopiera exakt rotation
                    
                    isRolling = false;
                    shakeCamera();
                }
            }
            requestAnimationFrame(animateStep);
        }

        function shakeCamera() {
            const origY = 8;
            const origZ = 11;
            let shake = 0;
            const shakeInterval = setInterval(() => {
                shake++;
                const intensity = (10 - shake) * 0.02;
                camera.position.y = origY + (Math.random() - 0.5) * intensity;
                camera.position.z = origZ + (Math.random() - 0.5) * intensity;
                camera.lookAt(0,0,0);
                
                if(shake > 15) {
                    clearInterval(shakeInterval);
                    camera.position.set(0, origY, origZ);
                    camera.lookAt(0,0,0);
                }
            }, 16);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!isRolling) {
                const time = Date.now() * 0.002;
                diceGroup.position.y = (FLOOR_Y + DICE_SIZE/2) + Math.sin(time) * 0.05;
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
